import 'package:flutter/material.dart';import 'package:flutter/services.dart';import 'package:flutter_svg/flutter_svg.dart';import 'package:smart_rob/widgets/tappable.dart';import '../core/core.dart';class AppTextField extends StatefulWidget {  const AppTextField({    required this.controller,    super.key,    this.hintText = '',    this.validator,    this.errorText,    this.label,    this.labelStyle,    this.contentPadHori,    this.contentPadVert,    this.obscureText = false,    this.errorStyle,    this.fillColor,    this.fontColor,    this.hintStyle,    this.height,    this.width,    this.errorBorder,    this.borderColor,    this.focusedColor,    this.borderRadius,    this.onChanged,    this.onComplete,    this.suffixIcon,    this.suffixIconConstraints,    this.prefixIcon,    this.prefixIconConstraints,    this.tapAction,    this.maxLines = 1,    this.minLines = 1,    this.enabled = true,    this.hideBorder = false,    this.readOnly = false,    this.isExpands = true,    this.autofocus = false,    this.hasError = false,    this.isOptional = true,    this.inputType,    this.inputStyle,    this.prefixText,    this.textDirection,    this.showCursor,    this.textAlignVertical,    this.textAlign = TextAlign.start,    this.focusNode,    this.errorMessage = '',    this.prefixIconImage,    this.labelWidget,    this.inputFormatters,    this.counter,    this.maxLength,    this.maxLengthEnforcement,    this.enableInteractiveSelection,    this.onTapOutside,  });  final String hintText;  final TextEditingController controller;  final String? Function(String?)? validator;  final String? errorText;  final String? prefixText;  final TextAlignVertical? textAlignVertical;  final TextStyle? errorStyle;  final TextStyle? hintStyle;  final TextStyle? inputStyle;  final double? height;  final InputBorder? errorBorder;  final TextDirection? textDirection;  final BorderRadius? borderRadius;  final Color? focusedColor;  final Color? borderColor;  final Color? fontColor;  final void Function(String)? onChanged;  final void Function(String)? onComplete;  final Widget? suffixIcon;  final BoxConstraints? suffixIconConstraints;  final Widget? prefixIcon;  final BoxConstraints? prefixIconConstraints;  final bool? showCursor;  final bool? enableInteractiveSelection;  final bool readOnly;  final bool isExpands;  final bool autofocus;  final bool isOptional;  final bool hasError;  final String errorMessage;  final String? prefixIconImage;  final double? width;  final Color? fillColor;  final String? label;  final TextInputType? inputType;  final TextAlign textAlign;  final bool obscureText;  final List<TextInputFormatter>? inputFormatters;  final TextStyle? labelStyle;  final double? contentPadHori;  final double? contentPadVert;  final int? maxLines;  final int? minLines;  final int? maxLength;  final MaxLengthEnforcement? maxLengthEnforcement;  final bool enabled;  final bool hideBorder;  final FocusNode? focusNode;  final Widget? labelWidget;  final Widget? counter;  final dynamic Function()? tapAction;  final Function(PointerDownEvent)? onTapOutside;  @override  State<AppTextField> createState() => _AppTextFieldState();}class _AppTextFieldState extends State<AppTextField> with SingleTickerProviderStateMixin {  late AnimationController _animationController;  final FocusNode _focusNode = FocusNode();  bool _isFocused = false;  bool _showText = false;  @override  void initState() {    super.initState();    (widget.focusNode ?? _focusNode).addListener(() {      if ((widget.focusNode ?? _focusNode).hasFocus == false) {        _isFocused = false;        widget.onComplete?.call(widget.controller.text);      } else {        _isFocused = true;      }      setState(() {});    });    _animationController = AnimationController(      vsync: this,      duration: const Duration(microseconds: 100),    );  }  @override  void didChangeDependencies() {    if (widget.autofocus) {      _focusNode.requestFocus();    }    super.didChangeDependencies();  }  @override  void dispose() {    super.dispose();    (widget.focusNode ?? _focusNode).dispose();    _animationController.dispose();  }  @override  Widget build(BuildContext context) {    return AnimatedBuilder(      animation: _animationController,      builder: (context, child) {        return Tappable(          onTap:              widget.tapAction ??              () {                setState(() {                  if (widget.focusNode != null) {                    widget.focusNode?.requestFocus();                  } else {                    _focusNode.requestFocus();                  }                });              },          child: Column(            crossAxisAlignment: CrossAxisAlignment.stretch,            children: [              if (widget.label != null || widget.labelWidget != null) ...[                widget.labelWidget ??                    Text.rich(                      TextSpan(                        text: widget.label,                        style:                            widget.labelStyle ??                            TextStyles.w400_12(context).copyWith(                              height: 14.62 / 12,                              color: widget.readOnly ? AppColors.black400 : AppColors.black,                            ),                        children: [                          if (!widget.isOptional)                            TextSpan(                              text: ' *',                              style: TextStyles.w800_12(context).copyWith(color: AppColors.error),                            ),                        ],                      ),                    ),                8.vSpace,              ],              SizedBox(                height: widget.height ?? 41.relHeight,                width: widget.width,                child: TextFormField(                  enableInteractiveSelection: widget.enableInteractiveSelection,                  contextMenuBuilder:                      (widget.enableInteractiveSelection ?? true)                          ? (context, editableTextState) {                            final buttonItems = editableTextState.contextMenuButtonItems;                            return AdaptiveTextSelectionToolbar.buttonItems(                              buttonItems: buttonItems,                              anchors: editableTextState.contextMenuAnchors,                            );                          }                          : null,                  textDirection: widget.textDirection,                  inputFormatters: widget.inputFormatters,                  maxLength: widget.maxLength,                  maxLengthEnforcement: widget.maxLengthEnforcement,                  focusNode: widget.focusNode ?? _focusNode,                  showCursor: widget.showCursor,                  autofocus: widget.autofocus,                  readOnly: widget.readOnly,                  textAlignVertical: widget.textAlignVertical,                  textAlign: widget.textAlign,                  keyboardType: widget.inputType,                  onTapOutside:                      widget.onTapOutside ??                      (event) {                        setState(() {                          if (widget.focusNode != null) {                            widget.focusNode?.unfocus();                          } else {                            _focusNode.unfocus();                          }                        });                      },                  onTap: () {                    if (widget.tapAction != null) {                      widget.tapAction?.call();                    }                    setState(() {                      if (widget.focusNode != null) {                        widget.focusNode?.requestFocus();                      } else {                        _focusNode.requestFocus();                      }                    });                  },                  maxLines: widget.isExpands ? null : widget.maxLines,                  minLines: widget.isExpands ? null : widget.maxLines,                  expands: widget.isExpands,                  style:                      widget.inputStyle ??                      TextStyles.w400_16(context).copyWith(                        fontSize: widget.obscureText && !_showText ? 12.text : 16.text,                        letterSpacing: widget.obscureText && !_showText ? 8 : null,                        color:                            widget.readOnly                                ? AppColors.black400                                : (widget.fontColor ?? AppColors.black),                      ),                  obscureText: widget.obscureText && !_showText,                  obscuringCharacter: '‚óè',                  cursorColor: AppColors.primary,                  decoration: InputDecoration(                    isDense: true,                    prefixIconConstraints: const BoxConstraints(),                    prefixIcon:                        widget.prefixIconImage != null && widget.prefixIconImage != null                            ? Container(                              padding: const EdgeInsets.only(left: 12, right: 8),                              child: SvgPicture.asset(                                widget.prefixIconImage!,                                height: 16,                                alignment: Alignment.topCenter,                              ),                            )                            : widget.prefixIcon,                    alignLabelWithHint: true,                    prefixText: widget.prefixText,                    prefixStyle: TextStyles.w400_14(                      context,                    ).copyWith(fontSize: 14, color: AppColors.black),                    fillColor:                        _isFocused                            ? (widget.hasError ? AppColors.white : AppColors.white)                            : widget.fillColor ?? AppColors.white,                    filled: true,                    counter: widget.counter,                    suffixIcon:                        widget.obscureText                            ? Tappable(                              onTap: () => setState(() => _showText = !_showText),                              child: Container(                                padding: const EdgeInsets.symmetric(                                  vertical: 14,                                ).copyWith(right: 16),                                child: Image.asset(                                  _showText ? 'assets/icons/eye-slash.png' : 'assets/icons/eye.png',                                ),                              ),                            )                            : widget.suffixIcon,                    contentPadding: EdgeInsets.symmetric(                      horizontal: widget.contentPadHori ?? 16,                      vertical: widget.contentPadVert ?? 0,                    ),                    hintText: widget.hintText,                    hintStyle:                        widget.hintStyle ??                        TextStyles.w400_14(context).copyWith(                          height: 1.3,                          color: Color(0XFF1E1E1E).withValues(alpha: 0.2),                          fontSize: widget.obscureText ? 12.text : null,                          letterSpacing: widget.obscureText ? 8 : null,                        ),                    errorStyle: TextStyle(color: AppColors.error, fontSize: 0),                    border:                        widget.hideBorder                            ? InputBorder.none                            : OutlineInputBorder(                              borderSide: BorderSide(                                width: 1,                                color:                                    !widget.hasError                                        ? (widget.borderColor ?? AppColors.border)                                        : AppColors.error,                              ),                              borderRadius: widget.borderRadius ?? BorderRadius.circular(8),                            ),                    enabledBorder:                        widget.hideBorder                            ? InputBorder.none                            : OutlineInputBorder(                              borderSide: BorderSide(                                width: 1,                                color:                                    !widget.hasError                                        ? (widget.borderColor ?? AppColors.border)                                        : AppColors.error,                              ), //<-- SEE HERE                              borderRadius: widget.borderRadius ?? BorderRadius.circular(8),                            ),                    disabledBorder: OutlineInputBorder(                      borderSide: BorderSide(                        width: 1,                        color:                            !widget.hasError                                ? (widget.borderColor ?? AppColors.border)                                : AppColors.error,                      ), //<-- SEE HERE                      borderRadius: widget.borderRadius ?? BorderRadius.circular(8),                    ),                    focusedBorder:                        widget.hideBorder                            ? InputBorder.none                            : OutlineInputBorder(                              borderSide: BorderSide(                                width: 1,                                strokeAlign: BorderSide.strokeAlignOutside,                                color:                                    !widget.hasError                                        ? (widget.focusedColor ?? AppColors.secondary)                                        : AppColors.error,                              ), //<-- SEE HERE                              borderRadius: widget.borderRadius ?? BorderRadius.circular(8),                            ),                  ),                  enabled: widget.enabled,                  controller: widget.controller,                  onChanged: widget.onChanged,                  validator: (value) {                    if (value == null || value.isEmpty) {                      return 'Please enter some text';                    }                    widget.validator?.call(value);                    return null;                  },                  onEditingComplete: () {                    setState(() {});                    FocusScope.of(context).unfocus();                    if (widget.onComplete != null) {                      widget.onComplete?.call(widget.controller.text);                    }                  },                ),              ),              if (widget.hasError && widget.errorMessage.isNotEmpty) ...[                4.vSpace,                Text(                  widget.errorMessage,                  style: TextStyles.w400_10(                    context,                  ).copyWith(color: Color(0XFF1E1E1E).withValues(alpha: 0.4)),                ),              ],            ],          ),        );      },    );  }}